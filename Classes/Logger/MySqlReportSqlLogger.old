<?php

declare(strict_types=1);

/*
 * This file is part of the package stefanfroemken/mysqlreport.
 *
 * For the full copyright and license information, please read the
 * LICENSE file that was distributed with this source code.
 */

namespace StefanFroemken\Mysqlreport\Logger;

use Doctrine\DBAL\Driver as DriverInterface;
use Doctrine\DBAL\Driver\Middleware;
use Doctrine\DBAL\Exception;
use StefanFroemken\Mysqlreport\Domain\Factory\ProfileFactory;
use StefanFroemken\Mysqlreport\Domain\Model\Profile;
use StefanFroemken\Mysqlreport\Helper\ConnectionHelper;
use TYPO3\CMS\Core\Configuration\Exception\ExtensionConfigurationExtensionNotConfiguredException;
use TYPO3\CMS\Core\Configuration\Exception\ExtensionConfigurationPathDoesNotExistException;
use TYPO3\CMS\Core\Configuration\ExtensionConfiguration;
use TYPO3\CMS\Core\Utility\GeneralUtility;

/**
 * This is an extended version of the DebugStack SQL logger
 * I have added profiling information
 */
class MySqlReportSqlLoggerOld implements Middleware
{
    /**
     * Collected profiles
     *
     * @var \SplQueue|Profile[]
     */
    public \SplQueue $profiles;

    protected ConnectionHelper $connectionHelper;

    protected ProfileFactory $profileFactory;

    /**
     * If enabled, this class will log queries
     */
    public bool $enabled = true;

    /**
     * Value from extension setting
     * Default to false, because "true" can reduce query execution a lot
     */
    public bool $addExplain = false;

    public float $start = 0.0;

    public int $queryIterator = 0;

    public function __construct(
        ProfileFactory $profileFactory,
        ConnectionHelper $connectionHelper,
        ExtensionConfiguration $extensionConfiguration
    ) {
        $this->profiles = new \SplQueue();

        $this->profileFactory = $profileFactory;

        $this->connectionHelper = $connectionHelper;
        if (!$this->connectionHelper->isConnectionAvailable()) {
            $this->enabled = false;
        }

        try {
            $this->addExplain = (bool)$extensionConfiguration->get('mysqlreport', 'addExplain');
        } catch (ExtensionConfigurationExtensionNotConfiguredException | ExtensionConfigurationPathDoesNotExistException $exception) {
            $this->addExplain = false;
        }
    }

    /**
     * Logs a SQL statement
     */
    public function startQuery($sql, ?array $params = null, ?array $types = null): void
    {
        if (!$this->enabled) {
            return;
        }

        $this->start = microtime(true);

        $profile = $this->profileFactory->createNewProfile();
        $profile->setQuery($sql);
        $profile->setQueryParameters($params);
        $profile->setQueryParameterTypes($types);

        $this->profiles->add($this->queryIterator, $profile);

        if ($this->addExplain) {
            $this->connectionHelper->executeQuery('SET profiling = 1');
        }
    }

    /**
     * Marks the last started query as stopped. This can be used for timing of queries.
     */
    public function stopQuery(): void
    {
        if (!$this->enabled) {
            return;
        }

        $this->profiles[$this->queryIterator]->setDuration(microtime(true) - $this->start);

        if ($this->addExplain) {
            if ($result = $this->connectionHelper->executeQuery('SHOW profile')) {
                $this->profiles[$this->queryIterator]->setProfile($result->fetchAll());
            }
            $this->updateExplainInformation($this->profiles[$this->queryIterator]);
        }

        $this->queryIterator++;
    }

    private function updateExplainInformation(Profile $profile): void
    {
        if ($this->addExplain === false) {
            return;
        }

        if ($profile->getQueryType() !== 'SELECT') {
            return;
        }

        try {
            if ($result = $this->connectionHelper->executeQuery($profile->getQueryForExplain())) {
                while ($explainResult = $result->fetchAssociative()) {
                    if (empty($explainResult['key'])) {
                        $profile->getExplainInformation()->setIsQueryUsingIndex(false);
                    }

                    if (strtolower($explainResult['type'] ?? '') === 'all') {
                        $profile->getExplainInformation()->setIsQueryUsingFTS(true);
                    }

                    $profile->getExplainInformation()->addExplainResult($explainResult);
                }
            }
        } catch (Exception|\Doctrine\DBAL\Driver\Exception $exception) {
            // Leave ExplainInformation unmodified
        }
    }

    public function __destruct()
    {
        if (!$this->connectionHelper->isConnectionAvailable()) {
            return;
        }

        if (!$this->isFrontendOrBackendProfilingActivated()) {
            return;
        }

        $this->sqlLoggerHelper->activateSqlLogger();

        $sqlLogger = $this->sqlLoggerHelper->getCurrentSqlLogger();
        if ($sqlLogger instanceof MySqlReportSqlLogger) {
            $queriesToStore = [];
            foreach ($sqlLogger->profiles as $key => $profile) {
                // Do not log our own queries
                if (strpos($profile->getQuery(), 'tx_mysqlreport_domain_model_profile') !== false) {
                    continue;
                }

                $queryToStore = [
                    'pid' => $profile->getPid(),
                    'ip' => $profile->getIp(),
                    'referer' => $profile->getReferer(),
                    'request' => $profile->getRequest(),
                    'query_type' => $profile->getQueryType(),
                    'duration' => $profile->getDuration(),
                    'query' => $profile->getQueryWithReplacedParameters(),
                    'profile' => serialize($profile->getProfile()),
                    'explain_query' => serialize($profile->getExplainInformation()->getExplainResults()),
                    'not_using_index' => $profile->getExplainInformation()->isQueryUsingIndex() ? 0 : 1,
                    'using_fulltable' => $profile->getExplainInformation()->isQueryUsingFTS() ? 1 : 0,
                    'mode' => $profile->getMode(),
                    'unique_call_identifier' => $profile->getUniqueCallIdentifier(),
                    'crdate' => $profile->getCrdate(),
                    'query_id' => $key,
                ];

                $queriesToStore[] = $queryToStore;
            }

            foreach (array_chunk($queriesToStore, 50) as $chunkOfQueriesToStore) {
                $this->connectionHelper->bulkInsert(
                    'tx_mysqlreport_domain_model_profile',
                    $chunkOfQueriesToStore,
                    [
                        'pid',
                        'ip',
                        'referer',
                        'request',
                        'query_type',
                        'duration',
                        'query',
                        'profile',
                        'explain_query',
                        'not_using_index',
                        'using_fulltable',
                        'mode',
                        'unique_call_identifier',
                        'crdate',
                        'query_id',
                    ]
                );
            }
        }
    }

    private function isFrontendOrBackendProfilingActivated(): bool
    {
        if (
            isset($this->extConf['profileFrontend'])
            && $this->extConf['profileFrontend']
            && $this->getTypo3Mode() === 'FE'
        ) {
            return true;
        }

        if (
            isset($this->extConf['profileBackend'])
            && $this->extConf['profileBackend']
            && $this->getTypo3Mode() === 'BE'
        ) {
            return true;
        }

        return false;
    }

    private function getTypo3Mode(): string
    {
        return GeneralUtility::getIndpEnv('SCRIPT_NAME') === '/typo3/index.php' ? 'BE' : 'FE';
    }
}
